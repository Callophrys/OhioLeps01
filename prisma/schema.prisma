// Prisma schema file
// Learn more at: https://pris.ly/d/prisma-schema

// added previewFeatures to allow for non-key uniques to work on updates
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum TaxonomicType {
    K
    P
    SP
    C
    O
    F
    SF
    G
    S
    SS
}

model Taxonomy {
    id Int @id @default(autoincrement())
    taxonType TaxonomicType
    latinName String
    commonName String?
    // Could calculate speciesCount.  But since already known and unlikely to change just populate it.
    speciesCount Int @default(0)

    // Parent of self
    baseTaxonId Int?
    baseTaxon   Taxonomy?   @relation("TaxonomicTree", fields: [baseTaxonId], references: [id])

    // Children of self
    branchTaxa  Taxonomy[]  @relation("TaxonomicTree")

    // Checklist - not working yet
    checklist  Checklist[] @relation("ChecklistOfTaxon")

    @@index([taxonType, latinName])
}

model AppConfig {
    id Int @id @default(autoincrement())
    configName String
    configType String
    configValue String

	createdAt DateTime @default(now())
	updatedAt DateTime?

    // User relations
	createdBy User? @relation("CreateUserOfAppConfig", fields: [createdById], references: [id])
	createdById String? // Probably should never be null
	updatedBy User? @relation("UpdateUserOfAppConfig", fields: [updatedById], references: [id])
	updatedById String?

    organizationId String
    organization Organization @relation("ConfigOfOrganization", fields: [organizationId], references: [id])

    @@unique([configName, organizationId])
}

model User {
    id              String   @id @default(uuid())
    username        String   @unique  // emailAddress
    firstName       String
    lastName        String
    passwordHash    String
    userAuthToken   String   @unique

    disabled        Boolean  @default(false)
    disabledReason  String?
    passwordRetries Int      @default(0) // e.g. disable account on 3, or turn on delay-until-retry feature
    delayedRetries  Int      @default(0) // if 3 times inside 3 days then disable account; Report to admins with user and IP and maybe headers too
    passwordExpires DateTime?

// maxLoginRetries', configType: 'number', configValue: '12', organizationId: templateOrganizationId ,
// attemptsBeforeDelay', configType: 'number', configValue: '3', organizationId: templateOrganizationId ,
// loginDelayTime', configType: 'number', configValue: '90', organizationId: templateOrganizationId ,
// maxLoginFailures', configType: 'number', configValue: '30', organizationId: templateOrganizationId ,
// maxLoginFailuresDays', configType: 'number', configValue: '30', organizationId: templateOrganizationId ,
// maxLoginDelays', configType: 'number', configValue: '3', organizationId: templateOrganizationId ,
// maxLoginDelaysDays', configType: 'number', configValue: '3', organizationId: templateOrganizationId ,

	createdAt DateTime @default(now())
	updatedAt DateTime?

    // User relations
	createdBy User? @relation("CreateUserOfUser", fields: [createdById], references: [id])
	createdById String? // Probably should never be null
	updatedBy User? @relation("UpdateUserOfUser", fields: [updatedById], references: [id])
	updatedById String?

    roleId String?
    role   Role? @relation(fields: [roleId], references: [id])

    organizationId String?
    organization Organization? @relation("UserOfOrganization", fields: [organizationId], references: [id])

    // Audit Relations
    //

    // Other users
    userCreatorOf User[] @relation("CreateUserOfUser")
    userUpdatorOf User[] @relation("UpdateUserOfUser")

    // Organization
    organizationCreatorOf Organization[] @relation("CreateUserOfOrganization")
    organizationUpdatorOf Organization[] @relation("UpdateUserOfOrganization")

    // AppConfigs
    appConfigCreatorOf AppConfig[] @relation("CreateUserOfAppConfig")
    appConfigUpdatorOf AppConfig[] @relation("UpdateUserOfAppConfig")

    // NameAddress
    nameAddressCreatorOf NameAddress[] @relation("CreateUserOfNameAddress")
    nameAddressUpdatorOf NameAddress[] @relation("UpdateUserOfNameAddress")

    // Site
    siteCreatorOf Site[] @relation("CreateUserOfSite")
    siteUpdatorOf Site[] @relation("UpdateUserOfSite")

    // SiteDate
    siteDateCreatorOf SiteDate[] @relation("CreateUserOfSiteDate")
    siteDateUpdatorOf SiteDate[] @relation("UpdateUserOfSiteDate")
    siteDateConfirmOf SiteDate[] @relation("ConfirmUserOfSiteDate")

    // SiteDateObservation
    siteDateObservationCreatorOf SiteDateObservation[] @relation("CreateUserOfSiteDateObservation")
    siteDateObservationUpdatorOf SiteDateObservation[] @relation("UpdateUserOfSiteDateObservation")
    siteDateObservationConfirmOf SiteDateObservation[] @relation("ConfirmUserOfSiteDateObservation")
}

model Organization {
    id String @id @default(uuid())
    name String @unique

    // Audit
	createdAt DateTime @default(now())
	updatedAt DateTime?

    // User relations
	createdBy User? @relation("CreateUserOfOrganization", fields: [createdById], references: [id])
	createdById String? // Probably should never be null
	updatedBy User? @relation("UpdateUserOfOrganization", fields: [updatedById], references: [id])
	updatedById String?

    appConfigs AppConfig[] @relation("ConfigOfOrganization")
    users User[]           @relation("UserOfOrganization")
}

// Could make this an enum
// SUPER - Superuser     - Can do all other user functions and configure any organization and manager any user
// ADMIN - Administrator - Administrator of own organization; Can make some org changes; Can do all other user functions; Can reset accounts for users
// REVIEWER - Reviewer   - Reviews and confirms that data is valid - Perhaps reviewer and entry can overlap.  E.g enter own data while another reviews it
// ENTRY - Data Entry    - Data entry, can delete own data
// USER - User           - Read-only, View Reports and lists
model Role {
    id    String @id @default(uuid())
    name  String @unique
    users User[]
}

model Site {
    siteId Int @id @default(autoincrement())
    siteName String // @db.String(30)
    township String? // @db.String(50)
    locationZip String? // @db.String(50)
    siteAddress String? // @db.String(40)
    siteAddress2 String? // @db.String(40)
    siteCityStateZip String? // @db.String(40)
    person String? // @db.String(30)
    address String? // @db.String(40)
    address2 String? // @db.String(40)
    cityStateZip String? // @db.String(40)
    phone String? // @db.String(12)
    email String? // @db.String(30)
    latitudeStart String? // @db.String(50)
    latitudeEnd String? // @db.String(50)
    altPerson String? // @db.String(30)
    altAddress String? // @db.String(40)
    altAddress2 String? // @db.String(40)
    altCityStateZip String? // @db.String(40)
    altPhone String? // @db.String(12)
    altEmail String? // @db.String(30)
    otherParticipants String? // @db.String(250)
    description String? @db.VarChar(2000) // @db.Text
    s1995 Int @default(5)
    s1996 Int @default(5)
    s1997 Int @default(5)
    s1998 Int @default(5)
    s1999 Int @default(5)
    s2000 Int @default(5)
    s2001 Int @default(5)
    s2002 Int @default(5)
    s2003 Int @default(5)
    s2004 Int @default(5)

    // Audit
	createdAt DateTime @default(now())
	updatedAt DateTime?

    // User relations
	createdBy User? @relation("CreateUserOfSite", fields: [createdById], references: [id])
	createdById String? // Probably should never be null
	updatedBy User? @relation("UpdateUserOfSite", fields: [updatedById], references: [id])
	updatedById String?

    // Parent Relation
    countyId Int
    county County @relation("SiteOfCounty", fields: [countyId], references: [id])

    // Parent Relation
    stateId Int
    state State @relation("SiteOfState", fields: [stateId], references: [id])

    // Child Relation
    siteDates SiteDate[]

    // Child Relation
    siteStatuses SiteStatus[]
}

// Will be one-to-one with big taxon data
model Checklist {
    checklistId Int @id @default(autoincrement())
    hodges String @default("A000") // or similar, note if another system, e.g. Patterson number
    genus String // @db.String(20) // doomed
    species String // @db.String(20) // doomed
    subspecies String? // @db.String(16) // doomed
    commonName String? // @db.String(30)
    show Boolean
    kind String // @db.String(1)
    revised String // @db.String(1)
    author String // @db.String(22)
    year String?
    referenceCount Int @default(0)
    // TODO: figure out this field and its spelling
    countyCount Int @default(0)
    endangered String? // @db.String(50)
    synonym String? // @db.String(50)
    family Int @default(0)
    gCKey Int @default(0)
    grp Int @default(0)
    tmp_SitesReporting Int?
    tmp_TotalCount Int?
    tmp_HighCount Int?

    @@index([genus])
    @@index([species])
    @@index([commonName])
    //@@unique([hodges])

    // Child Relation
    siteDateObservations SiteDateObservation[]

    // Parent Relation
    taxonId Int?
    taxon   Taxonomy? @relation("ChecklistOfTaxon", fields: [taxonId], references: [id])
}

model SiteDateObservation {
    siteDateObservationId Int @id @default(autoincrement())
    // ** use siteDateObservationId as real key now - and later just drop 'seqId Int?'
    seqId Int?
    hodges String? // hodges + siteDateId would be unique
    idCode String? // @db.String(1)  // in { how id'ed:  O observ, N net, P photo, C collected }
    section1 Int?        // counts of CheckList species per section
    section2 Int?
    section3 Int?
    section4 Int?
    section5 Int?
    section6 Int?
    section7 Int?
    section8 Int?
    section9 Int?
    section10 Int?
    section11 Int?
    section12 Int?
    section13 Int?
    section14 Int?
    section15 Int?
    mark String? // @db.String(50)

    deleted Boolean @default(false)
    confirmed Boolean @default(false)

	createdAt DateTime?
	updatedAt DateTime?
	confirmAt DateTime?

    // User relations
	createdBy User? @relation("CreateUserOfSiteDateObservation", fields: [createdById], references: [id])
	createdById String? // Probably should never be null
	updatedBy User? @relation("UpdateUserOfSiteDateObservation", fields: [updatedById], references: [id])
	updatedById String?
	confirmBy User? @relation("ConfirmUserOfSiteDateObservation", fields: [confirmById], references: [id])
	confirmById String?

    // Parent Relation
    checklist Checklist? @relation(fields: [checklistId], references: [checklistId])
    checklistId Int? // Probably should never be null

    // Parent Relation
    siteDate SiteDate? @relation(fields: [siteDateId], references: [siteDateId])
    siteDateId Int? // Should never be null

    //@@index([checklistId]); // error on run
    //@@index([siteDateId]);  // error on run
}

model StatusCode {
    statusCodeId Int @id
    code String
    description String

    // Child Relation
    siteStatuses SiteStatus[]
}

model SiteStatus {
    siteStatusId Int @id @default(autoincrement())
    siteId Int?
    statusCodeId Int?
    year Int

    // Parent Relation
    statusCode StatusCode? @relation(fields: [statusCodeId], references: [statusCodeId])
    // provided by load: 'statusCodeId Int'

    // Parent Relation
    site Site? @relation(fields: [siteId], references: [siteId])
    // provided by load: 'siteId Int'

    @@unique([siteId, year])
    @@index([siteId])
}

enum Weather {
    U
    O
    R
    S
}

model SiteDate {
    siteDateId Int @id // @default(autoincrement())
    siteId Int
    seqId Int? // temp and will be query key
    recordDate DateTime // was "date", a reserved word
    week Int
    recorder String // @db.String(25)
    startTime DateTime?
    endTime DateTime?
    startTemp Int?
    endTemp Int?
    startClouds Int?
    endClouds Int?
    startWindDir String? // @db.String(3)
    endWindDir String? // @db.String(3)
    startWindMPH Int?
    endWindMPH Int?
    w1 Weather @default(U)
    w2 Weather @default(U)
    w3 Weather @default(U)
    w4 Weather @default(U)
    w5 Weather @default(U)
    w6 Weather @default(U)
    w7 Weather @default(U)
    w8 Weather @default(U)
    w9 Weather @default(U)
    w10 Weather @default(U)
    w11 Weather @default(U)
    w12 Weather @default(U)
    w13 Weather @default(U)
    w14 Weather @default(U)
    w15 Weather @default(U)
    lEsec1 String? // @db.String(8)
    lEsec2 String? // @db.String(8)
    lEsec3 String? // @db.String(8)
    lEsec4 String? // @db.String(8)
    lEsec5 String? // @db.String(8)
    lEsec6 String? // @db.String(8)
    lEsec7 String? // @db.String(8)
    lEsec8 String? // @db.String(8)
    lEsec9 String? // @db.String(8)
    lEsec10 String? // @db.String(8)
    lEsec11 String? // @db.String(8)
    lEsec12 String? // @db.String(8)
    lEsec13 String? // @db.String(8)
    lEsec14 String? // @db.String(8)
    lEsec15 String? // @db.String(8)
    larvaObA String? // @db.String(25)
    larvaObB String? // @db.String(25)
    larvaObC String? // @db.String(25)
    larvaObD String? // @db.String(25)
    energySource1 String? // @db.String(25)
    energySource2 String? // @db.String(25)
    energySource3 String? // @db.String(25)
    energySource4 String? // @db.String(25)
    flowersInBloom String? // @db.String(150)
    fieldNotes String? // @db.String(100)

    // Audit
    deleted Boolean @default(false)
    confirmed Boolean @default(false)
    createdAt DateTime?
    updatedAt DateTime?
    confirmAt DateTime?

    // User relations
    createdBy User? @relation("CreateUserOfSiteDate", fields: [createdById], references: [id])
    createdById String? // Probably should never be null
    updatedBy User? @relation("UpdateUserOfSiteDate", fields: [updatedById], references: [id])
    updatedById String?
    confirmBy User? @relation("ConfirmUserOfSiteDate", fields: [confirmById], references: [id])
    confirmById String?

    // Parent Relation
    site Site @relation(fields: [siteId], references: [siteId])
    // provided by load: siteId Int //@default(0)

    // Child Relation
    siteDateObservations SiteDateObservation[]

    @@index([siteId])
}

model NameAddress {
    nameAddressId Int @id @default(autoincrement())
    fullName String
    firstName String?
    lastName String?
    middleName String?
    nameSuffix String? // JR, III
    postNominal String? // MD, PhD, JD
    nameAddend String?  // "Naturalist", place, magazine, etc.
    organization String?
    address String?
    cityStateZip String?
    phone String?
    mobile String?
    emailAddress String?
    notes String?
    notes2 String?

    // Audit
    createdAt DateTime?
    updatedAt DateTime?

    // User relations
    createdBy User? @relation("CreateUserOfNameAddress", fields: [createdById], references: [id])
    createdById String? // Probably should never be null
    updatedBy User? @relation("UpdateUserOfNameAddress", fields: [updatedById], references: [id])
    updatedById String?
}

model Continent {
    id Int @id @default(autoincrement())
    abbreviation String @db.VarChar(2) @unique
    name String @unique

    // Child Relation
    countries Country[] @relation("ContinentOfCountry")
}

model Country {
    id Int @id @default(autoincrement())
    abbreviation String @db.VarChar(2) @unique
    name String @unique

    // Parent Relation
    continentId Int
    continent Continent @relation("ContinentOfCountry", fields: [continentId], references: [id])

    // Child Relation
    states State[] @relation("CountryOfState")
}

model State {
    id Int @id @default(autoincrement())
    abbreviation String @db.VarChar(4)
    name String

    // Parent Relation
    countryId Int
    country Country @relation("CountryOfState", fields: [countryId], references: [id])

    // Child Relation
    regions Region[] @relation("StateOfRegion")

    // Child Relation
    counties County[] @relation("StateOfCounty")

    // Child Relation
    sites Site[] @relation("SiteOfState")
}

model Region {
    id Int @id @default(autoincrement())
    name String

    // Parent Relation
    stateId Int
    state State @relation("StateOfRegion", fields: [stateId], references: [id])

    // Child Relation
    counties County[] @relation("RegionOfCounty")
}

model County {
    id Int @id @default(autoincrement())
    name String

    // Parent Relation
    regionId Int
    region Region @relation("RegionOfCounty", fields: [regionId], references: [id])

    // Parent Relation
    stateId Int
    state State @relation("StateOfCounty", fields: [stateId], references: [id])

    // Child Relation
    sites Site[] @relation("SiteOfCounty")
}
